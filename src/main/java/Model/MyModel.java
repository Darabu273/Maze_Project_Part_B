package Model;import Client.Client;import IO.MyDecompressorInputStream;import Server.Server;import algorithms.mazeGenerators.IMazeGenerator;import algorithms.mazeGenerators.Maze;import algorithms.search.*;import Server.ServerStrategyGenerateMaze;import Server.ServerStrategySolveSearchProblem;import Client.IClientStrategy;import org.apache.logging.log4j.LogManager;import org.apache.logging.log4j.Logger;import Server.Configurations;import java.io.*;import java.net.InetAddress;import java.util.Observable;import java.util.Observer;public class MyModel extends Observable implements IModel {    private static MyModel ModelInstance;    private Maze modelMaze;    private int PlayerRow;    private int PlayerCol;    private Solution modelMazeSolution;    private Server GenerateMazeServer;    private Server SolveMazeServer;    private static final Logger LOG = LogManager.getLogger();    private MyModel() {        modelMaze = null;        PlayerRow = 0;        PlayerCol = 0;        modelMazeSolution = null;        initServers();    }    public static MyModel getInstance(){        if(ModelInstance == null)            ModelInstance = new MyModel();        return ModelInstance;    }    public Maze getMaze(){        return modelMaze;    }    public int getPlayerRow() {        return PlayerRow;    }    public int getPlayerCol() {        return PlayerCol;    }    public void deleteSolution() {        modelMazeSolution = null;    }    @Override    public Solution getSolution() {        return modelMazeSolution;    }    @Override    public void solveMaze() {        //Solving Maze        LOG.info("Start solving maze operation");        ISearchingAlgorithm searcher = Configurations.getSearchingAlgorithm();        LOG.info("Current Solver = " + catString(searcher.getClass().toString()));        try{            Client client = new Client(InetAddress.getLocalHost(), 5401, new IClientStrategy() {                @Override                public void clientStrategy(InputStream inputStream, OutputStream outputStream) {                    try{                        ObjectOutputStream toServer = new ObjectOutputStream(outputStream);                        ObjectInputStream fromServer = new ObjectInputStream(inputStream);                        toServer.flush();                        toServer.writeObject(modelMaze); //send maze to server                        toServer.flush();                        modelMazeSolution = (Solution) fromServer.readObject(); //read generated maze (compressed with MyCompressor) from server                        LOG.info("Solution path length = " + modelMazeSolution.getSolutionPath().size());                    } catch (Exception e) {                        LOG.error("Connection failed - server couldn't solve the given maze");}}});            client.communicateWithServer();            LOG.info("Client " + InetAddress.getLocalHost() + " connected to server with port 5400, for solving the maze");        }        catch(IOException e){            LOG.error("Connection to server with port 5401 has failed");        }        LOG.info("Finish solving maze..");        setChanged();        notifyObservers("ModelSolvedMaze");    }    public void generateMaze(int rows, int cols){ //create Maze        LOG.info("Start generating maze operation, with Rows = " + rows + " and Columns = " + cols);        IMazeGenerator generator = Configurations.getGeneratingAlgorithm();        LOG.info("Generating algorithm = " + catString(generator.getClass().toString()));        String action = "ModelGenerateMaze";        try{            Client client = new Client(InetAddress.getLocalHost(), 5400, new IClientStrategy() {                public void clientStrategy(InputStream inputStream, OutputStream outputStream){                    try{                        ObjectOutputStream toServer = new ObjectOutputStream(outputStream);                        ObjectInputStream fromServer = new ObjectInputStream(inputStream);                        toServer.flush();                        int[] mazeDimensions = new int[]{rows, cols};                        toServer.writeObject(mazeDimensions);                        toServer.flush();                        byte[] compressedMaze = (byte[]) fromServer.readObject(); //read generated maze (compressed with MyCompressor) from server                        InputStream is = new MyDecompressorInputStream(new ByteArrayInputStream(compressedMaze));                        byte[] decompressedMaze = new byte[mazeDimensions[0]*mazeDimensions[1]+12]; //allocating byte[] for the decompressed maze -                        is.read(decompressedMaze); //Fill decompressedMaze with bytes                        modelMaze = new Maze(decompressedMaze);                        PlayerRow =modelMaze.getStartPosition().getRowIndex();                        PlayerCol = modelMaze.getStartPosition().getColumnIndex();                        LOG.debug("Player start position = {" + PlayerRow +"," + PlayerCol + "}");                        LOG.debug("Player goal position = {" + modelMaze.getGoalPosition().getRowIndex() +"," + modelMaze.getGoalPosition().getColumnIndex() + "}");                    }                    catch (Exception e) {                        LOG.error("Connection failed - server couldn't create the new maze");                    }                }            });            client.communicateWithServer();            LOG.info("Client " + InetAddress.getLocalHost() + " connected to server with port 5400, for creating the maze");        }        catch (Exception e) {            LOG.error("Connection to server with port 5400 has failed");        }        LOG.info("Finish generating maze operation");        deleteSolution();        setChanged();        notifyObservers(action);    }    public void setLoadedMaze(Maze loadedMaze){        String action = "ModelLoadedMaze";        LOG.info("Set Loaded maze to MyModel instance..");        modelMaze = loadedMaze;        PlayerRow =modelMaze.getStartPosition().getRowIndex();        PlayerCol = modelMaze.getStartPosition().getColumnIndex();        deleteSolution();        setChanged();        notifyObservers(action);    }    public void UpdatePlayerPosition(int direction){ //Update Location of the character is the Maze        LOG.info("Request to update player position has been made");        String ActionMessage = "ModelUpdatePlayerPosition";        switch (direction) {            case 0:                PlayerRow =modelMaze.getStartPosition().getRowIndex();                PlayerCol = modelMaze.getStartPosition().getColumnIndex();                ActionMessage = "restartPlayerPosition";                LOG.info("Player moved to the start position of the maze");                break;            case 8:                if(PlayerRow>0)                    if(modelMaze.getMazeContent()[PlayerRow-1][PlayerCol]==0)                        PlayerRow--; //UP                    else{ActionMessage = "Wall";}                else{ActionMessage = "BoundariesProblem";}                break;            case 2:                if(PlayerRow<modelMaze.getRows()-1)                    if(modelMaze.getMazeContent()[PlayerRow+1][PlayerCol]==0)                        PlayerRow++; //DOWN                    else{ActionMessage = "Wall";}                else{ActionMessage = "BoundariesProblem";}                break;            case 4:                if(PlayerCol>0)                    if(modelMaze.getMazeContent()[PlayerRow][PlayerCol-1]==0)                        PlayerCol--; //LEFT                    else{ActionMessage = "Wall";}                else{ActionMessage = "BoundariesProblem";}                break;            case 6:                if(PlayerCol<modelMaze.getColumns()-1)                    if(modelMaze.getMazeContent()[PlayerRow][PlayerCol+1]==0)                        PlayerCol++; //RIGHT                    else{ActionMessage = "Wall";}                else{ActionMessage = "BoundariesProblem";}                break;            case 1:                if((PlayerRow<modelMaze.getRows()-1)&&(PlayerCol>0)){                    if(modelMaze.getMazeContent()[PlayerRow+1][PlayerCol-1]==0){                        PlayerRow++; //DOWN                        PlayerCol--; //LEFT                    }                    else{ActionMessage = "Wall";}                }                else{ActionMessage = "BoundariesProblem";}                break;            case 3:                if((PlayerRow<modelMaze.getRows()-1)&&(PlayerCol<modelMaze.getColumns()-1)){                    if(modelMaze.getMazeContent()[PlayerRow+1][PlayerCol+1]==0){                        PlayerRow++; //DOWN                        PlayerCol++; //RIGHT                    }                    else{ActionMessage = "Wall";}                }                else{ActionMessage = "BoundariesProblem";}                break;            case 7:                if((PlayerRow>0)&&(PlayerCol>0)){                    if(modelMaze.getMazeContent()[PlayerRow-1][PlayerCol-1]==0){                        PlayerRow--; //UP                        PlayerCol--; //LEFT                    }                    else{ActionMessage = "Wall";}                }                else{ActionMessage = "BoundariesProblem";}                break;            case 9:                if((PlayerRow>0)&&(PlayerCol<modelMaze.getColumns()-1)){                    if(modelMaze.getMazeContent()[PlayerRow-1][PlayerCol+1]==0){                        PlayerRow--; //UP                        PlayerCol++; //RIGHT                    }                    else{ActionMessage = "Wall";}                }                else{ActionMessage = "BoundariesProblem";}                break;        }        String currPlayerPosition = "{" + PlayerRow + "," + PlayerCol + "}";        if(currPlayerPosition.equals(modelMaze.getGoalPosition().toString())){            ActionMessage = "UserSolvedTheMaze";            LOG.info("The user solved the maze");        }        setChanged();        notifyObservers(ActionMessage);    }    @Override    public void assignObserver(Observer O) {        this.addObserver(O);    }    public void shutDownServers(){        GenerateMazeServer.stop();        LOG.info("stop GenerateMazeServer (port 5400)");        SolveMazeServer.stop();        LOG.info("stop SolveMazeServer (port 5401)");        GenerateMazeServer.JoinTermination();        SolveMazeServer.JoinTermination();    }    public void initServers(){        GenerateMazeServer = new Server(5400, 1000, new ServerStrategyGenerateMaze());        SolveMazeServer = new Server(5401, 1000, new ServerStrategySolveSearchProblem());        GenerateMazeServer.start();        SolveMazeServer.start();        LOG.info("Starting GenerateMazeServer at port = 5400");        LOG.info("Starting SolveMazeServer at port = 5401");    }    private String catString(String str){        int i = str.indexOf(".");        str = str.substring(i+1);        i = str.indexOf(".");        return str.substring(i+1);    }}