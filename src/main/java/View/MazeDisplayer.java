package View;import algorithms.mazeGenerators.Maze;import algorithms.mazeGenerators.Position;import algorithms.search.AState;import algorithms.search.Solution;import javafx.beans.property.SimpleStringProperty;import javafx.scene.canvas.Canvas;import javafx.scene.canvas.GraphicsContext;import javafx.scene.control.Alert;import javafx.scene.control.Button;import javafx.scene.image.Image;import javafx.scene.paint.Color;import javafx.beans.property.StringProperty;import javafx.scene.text.Text;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.util.ArrayList;/** * MazeDisplayer extends Canvas class - response for maze drawing (include walls & player & start and goal position) * * Fields: *     Image PlayerImage: will hold the image of the current player *     Image StartImage: will hold the image of the start position *     Image GoalImage: will hold the image of the end position *     Image wallImage (until 4): will hold the images of the walls *     Image solutionImage: will hold the image of the solution cells *     Maze mazeDisplay: the maze that we would like to draw *     int PlayerRow, PlayerCol: hold the player current position *     Boolean drawSolution: define if we want to draw the solution *     Solution solution: solution of the current maze (mazeDisplay) *     ArrayList<Integer> solutionDraw : holds value for each state of the solution path (0 = need to draw, 1 = no need to draw) * */public class MazeDisplayer extends Canvas {    //images StringProperties    StringProperty imageFileNameWall = new SimpleStringProperty();    StringProperty imageFileNameWall2 = new SimpleStringProperty();    StringProperty imageFileNameWall3 = new SimpleStringProperty();    StringProperty imageFileNameWall4 = new SimpleStringProperty();    StringProperty imageFileNameWall5 = new SimpleStringProperty();    StringProperty imageFileNameAriel = new SimpleStringProperty();    StringProperty imageFileNameFlounder = new SimpleStringProperty();    StringProperty imageFileNameSebastian = new SimpleStringProperty();    StringProperty imageFileNameUrsula = new SimpleStringProperty();    StringProperty imageFileNameStartPosition = new SimpleStringProperty();    StringProperty imageFileNameGoalPosition = new SimpleStringProperty();    StringProperty imageFileNameSolution = new SimpleStringProperty();    Image PlayerImage = null;    Image StartImage = null;    Image GoalImage = null;    Image wallImage,wallImage2,wallImage3,wallImage4,wallImage5 = null;    Image solutionImage = null;    private Maze mazeDisplay;    private int PlayerRow = 0;    private int PlayerCol = 0;    private Boolean drawSolution = false;    private Solution solution = null;    private int[] solutionDraw;    Text pearlsNumber = null;    private double deltaX = 0 ;    private  double deltaY = 0;    //constructor    public MazeDisplayer() {        widthProperty().addListener(e -> draw()); //listen to resize event        heightProperty().addListener(e -> draw());    }    //update player position - draw again, because player moved    public void setPlayerPosition(int Row, int Col) {        PlayerRow = Row;        PlayerCol = Col;        draw(); }    //draw maze, after update the solution field    public void DrawWhenSolve(Solution ViewSolution){        pearlsNumber.setText("0"); //reset collected pearls number        solution=ViewSolution; //update solution        solutionDraw = new int[solution.getSolutionPath().size()];//reset solutionDraw (manage the visited cells of the solution, for pearls "eating" while walking in the maze)        draw();}    public void restartSolutionPath() {        pearlsNumber.setText("0"); //reset collected pearls number        if(solution != null)            solutionDraw = new int[solution.getSolutionPath().size()];    }    //show or hide solution - change button text & drawSolution field    public void ChangeDrawSolution(Button btn) {        if(drawSolution){            btn.setText("Show Pearl-Path to Eric");            drawSolution=false;}        else{            btn.setText("Hide Pearl-Path to Eric");            drawSolution=true;}}    //change drawSolution to false & set the right text on the button    public void FalseDrawSolution(Button btn) {        drawSolution=false;        btn.setText("Show Pearl-Path to Eric");}    //draw maze elements    private void draw() {        if(mazeDisplay != null){            //find the canvas sizes, and split into rows*cols cells            double canvasHeight = getHeight();            double canvasWidth = getWidth();            int rows = mazeDisplay.getRows();            int cols = mazeDisplay.getColumns();            //calculate cell dimensions            double cellHeight = canvasHeight / rows;            double cellWidth = canvasWidth / cols;            GraphicsContext graphicsContext = getGraphicsContext2D();            graphicsContext.clearRect(0, 0, canvasWidth, canvasHeight);            drawMazeWalls(graphicsContext, rows, cols, cellHeight, cellWidth); //draw maze walls function            if(drawSolution)                if(solution==null) {                    ErrorMessage("there is no solution to draw");}                else                    drawSolution(graphicsContext, cellHeight, cellWidth); //draw maze solution function            drawMazePlayer(graphicsContext, cellHeight, cellWidth);  //draw player function            drawMazeStartAndGoal(graphicsContext, cellHeight, cellWidth);  //draw maze start & goal cells function        }}    //draw the solution of the maze    private void drawSolution(GraphicsContext graphicsContext, double cellHeight, double cellWidth) {        if(solutionImage==null){            try {                solutionImage = new Image(new FileInputStream(getImageFileNameSolution()));            } catch (FileNotFoundException e) {                ErrorMessage("There is no image for the solution");}        }        double Width = (cellWidth/4);        double Height = (cellHeight/4);        double WidthX = cellWidth/3;        double WidthY = cellHeight/(2.5);        graphicsContext.setFill(Color.BLUE);        ArrayList<AState> solutionPath = solution.getSolutionPath();        for (int i = 0; i < solutionPath.size(); i++) { //iterate over all solution positions, and draw them all            String position = solutionPath.get(i).toString();            try {                if((position.equals((new Position(PlayerRow, PlayerCol)).toString())) && (solutionDraw[i] == 0)){                    solutionDraw[i] = 1;                    if(!(position.equals(mazeDisplay.getStartPosition().toString())) && !(position.equals(mazeDisplay.getGoalPosition().toString()))){                        int pearlsNum = ((Integer.parseInt(pearlsNumber.getText()))+1);                        pearlsNumber.setText(String.valueOf(pearlsNum));                    }                }                if((solutionDraw[i] == 1) || position.equals(mazeDisplay.getStartPosition().toString()) || position.equals(mazeDisplay.getGoalPosition().toString())){                    continue; //don't draw over the start & goal positions , and not where the player placed                }            } catch (Exception e) {                ErrorMessage("Error occurred while drawing solution function (Position create exception)");            }            int index = position.indexOf(",");            String posX = position.substring(1,index);            String posY = position.substring(index+1, position.length()-1);            double H = Integer.parseInt(posX) * cellHeight;            double W = Integer.parseInt(posY) * cellWidth;            if(solutionImage== null)                graphicsContext.fillRect(W+WidthY, H+WidthX, Width, Height);            else                graphicsContext.drawImage(solutionImage, W+WidthY, H+WidthX, Width, Height);        }    }    //draw the player in the maze    private void drawMazePlayer(GraphicsContext graphicsContext, double cellHeight, double cellWidth) {        double x = getPlayerCol() * cellWidth;        double y = getPlayerRow() * cellHeight;        graphicsContext.setFill(Color.GREEN);        if(PlayerImage == null){            graphicsContext.fillRect(x-deltaX, y-deltaY, cellWidth, cellHeight);}        else{            graphicsContext.drawImage(PlayerImage, x-deltaX, y-deltaY, cellWidth, cellHeight);        }    }    //draw maze start & goal positions    private void drawMazeStartAndGoal(GraphicsContext graphicsContext, double cellHeight, double cellWidth) {        if(StartImage==null){            try {                StartImage = new Image(new FileInputStream(getImageFileNameStartPosition()));            } catch (FileNotFoundException e) {                ErrorMessage("There is no Start image");            }        }        if(GoalImage==null){            try {                GoalImage = new Image(new FileInputStream(getImageFileNameGoalPosition()));            } catch (FileNotFoundException e) {                ErrorMessage("There is no Goal image");            }        }        double x_Start = mazeDisplay.getStartPosition().getColumnIndex() * cellWidth;        double y_Start = mazeDisplay.getStartPosition().getRowIndex() * cellHeight;        double x_Goal = mazeDisplay.getGoalPosition().getColumnIndex() * cellWidth;        double y_Goal = mazeDisplay.getGoalPosition().getRowIndex() * cellHeight;        graphicsContext.setFill(Color.BLUEVIOLET); //the color that we want to add in our draw        //draw the Start image only when the player isn't there        if((mazeDisplay.getStartPosition().getRowIndex() != this.PlayerRow) || (mazeDisplay.getStartPosition().getColumnIndex() != this.PlayerCol))        {            if(StartImage== null)                graphicsContext.fillRect(x_Start-deltaX, y_Start-deltaY, cellWidth, cellHeight);            else                graphicsContext.drawImage(StartImage, x_Start-deltaX, y_Start-deltaY, cellWidth, cellHeight);        }        graphicsContext.setFill(Color.GREENYELLOW); //the color that we want to add in our draw        //draw the Goal image only when the player isn't there        if((mazeDisplay.getGoalPosition().getRowIndex() != this.PlayerRow) || (mazeDisplay.getGoalPosition().getColumnIndex() != this.PlayerCol))        {            if(GoalImage== null)                graphicsContext.fillRect(x_Goal-deltaX, y_Goal-deltaY, cellWidth, cellHeight);            else                graphicsContext.drawImage(GoalImage, x_Goal-deltaX, y_Goal-deltaY, cellWidth, cellHeight);        }    }    //draw maze walls    private void drawMazeWalls(GraphicsContext graphicsContext, int rows, int cols, double cellHeight, double cellWidth) {        if(wallImage==null){            try {wallImage = new Image(new FileInputStream(getImageFileNameWall()));}            catch (FileNotFoundException e) {System.out.println("There is no wall image");}}        if(wallImage2==null){            try {wallImage2 = new Image(new FileInputStream(getImageFileNameWall2()));}            catch (FileNotFoundException e) {System.out.println("There is no wall image");}}        if(wallImage3==null){            try {wallImage3 = new Image(new FileInputStream(getImageFileNameWall3()));}            catch (FileNotFoundException e) {System.out.println("There is no wall image");}}        if(wallImage4==null){            try {wallImage4 = new Image(new FileInputStream(getImageFileNameWall4()));}            catch (FileNotFoundException e) {System.out.println("There is no wall image");}}        if(wallImage5==null){            try {wallImage5 = new Image(new FileInputStream(getImageFileNameWall5()));}            catch (FileNotFoundException e) {System.out.println("There is no wall image");}}        graphicsContext.setFill(Color.BLUE); //the color that we want to add in our draw        //calculate sizes:        double Width = 2*(cellWidth/3);        double Height = 2*(cellHeight/3);        double WidthX = cellWidth/6;        double WidthY = cellHeight/6;        int counter = 0; //will use us to find the right image for each cell, and to save the order        Image selected = null;        //iterate over all cells, if the cell value = 1, fill the cell with image        for (int i = 0; i < rows; i++) {            for (int j = 0; j < cols; j++) {                if(mazeDisplay.getMazeContent()[i][j] == 1){                    //if it is a wall:                    double x = j * cellWidth;                    double y = i * cellHeight;                    switch (counter) { //choose the right image                        case 0 -> selected = wallImage;                        case 1 -> selected = wallImage2;                        case 2 -> selected = wallImage3;                        case 3 -> selected= wallImage4;                        case 4 -> {                            selected = wallImage5;                            counter = -1;}}                    counter++;                    if(wallImage== null)                        graphicsContext.fillRect(x+WidthX-deltaX, y+WidthY-deltaY, Width, Height);                    else                        graphicsContext.drawImage(selected, x+WidthX-deltaX, y+WidthY-deltaY, Width, Height);                }}}    }    public void drawMaze(){        draw();    }    /*----------    Alert    ----------*/    private void ErrorMessage(String message){        Alert alert = new Alert(Alert.AlertType.ERROR);        alert.setContentText(message);        alert.setTitle("");        alert.show(); }    //getters & setters    public double getCellHeight() { return getHeight()/mazeDisplay.getRows(); }    public double getCellWidth() { return getWidth()/mazeDisplay.getColumns(); }    //after zoom-in we'll set DeltaX and DeltaY for moving on the rest of the window    public void setDeltaX(double deltaX) { this.deltaX += deltaX;}    public void setDeltaY(double deltaY) {this.deltaY += deltaY;}    public double getDeltaX() {        return deltaX;    }    public double getDeltaY() {        return deltaY;    }    public void setMazeDisplay(Maze mazeDisplay) {        this.mazeDisplay = mazeDisplay;}    public void deleteSolution() {        this.solution = null;        solutionDraw = null;        pearlsNumber.setText("0");    }    public Solution getSolution() {        return solution;    }    public Boolean getDrawSolution() {        return drawSolution;    }    public void setImageFileNameStartPosition(String imageFileNameStartPosition) {this.imageFileNameStartPosition.set(imageFileNameStartPosition);}    public String getImageFileNameFlounder() {return imageFileNameFlounder.get();}    public String getImageFileNameSebastian() { return imageFileNameSebastian.get();}    public void setImageFileNameSebastian(String imageFileNameSebastian) { this.imageFileNameSebastian.set(imageFileNameSebastian);}    public String getImageFileNameWall() {        return imageFileNameWall.get();    }    public void setImageFileNameWall(String imageFileNameWall) {        this.imageFileNameWall.set(imageFileNameWall);    }    public String getImageFileNameStartPosition() {        return imageFileNameStartPosition.get();    }    public String getImageFileNameGoalPosition() {        return imageFileNameGoalPosition.get();    }    public String getImageFileNameSolution() {        return imageFileNameSolution.get();    }    public void setImageFileNameSolution(String imageFileNameSolution) { this.imageFileNameSolution.set(imageFileNameSolution);}    public String getImageFileNameWall3() {        return imageFileNameWall3.get();    }    public void setImageFileNameWall3(String imageFileNameWall3) {        this.imageFileNameWall3.set(imageFileNameWall3);    }    public String getImageFileNameWall4() {        return imageFileNameWall4.get();    }    public void setImageFileNameWall4(String imageFileNameWall4) {        this.imageFileNameWall4.set(imageFileNameWall4);    }    public void setImageFileNameFlounder(String imageFileNameFlounder) {this.imageFileNameFlounder.set(imageFileNameFlounder);}    public String getImageFileNameUrsula() {return imageFileNameUrsula.get();}    public void setImageFileNameUrsula(String imageFileNameUrsula) { this.imageFileNameUrsula.set(imageFileNameUrsula);}    public void setImageFileNameGoalPosition(String imageFileNameGoalPosition) {this.imageFileNameGoalPosition.set(imageFileNameGoalPosition);}    public String getImageFileNameAriel() {return imageFileNameAriel.get();}    public void setImageFileNameAriel(String imageFileNameAriel) { this.imageFileNameAriel.set(imageFileNameAriel);}    public String getImageFileNameWall2() {        return imageFileNameWall2.get();    }    public String getImageFileNameWall5() {        return imageFileNameWall5.get();    }    public void setImageFileNameWall5(String imageFileNameWall5) {        this.imageFileNameWall5.set(imageFileNameWall5);    }    public void setImageFileNameWall2(String imageFileNameWall2) {        this.imageFileNameWall2.set(imageFileNameWall2);    }    public int getPlayerRow() {        return PlayerRow;    }    public int getPlayerCol() {        return PlayerCol;    }    //update the image of the player that the mazeDisplayer holds    public void setPlayer(String player) {        try {            switch (player){ //find the player that the user asked for , and draw it                case "Ariel" -> PlayerImage=new Image(new FileInputStream(getImageFileNameAriel()));                case "Ursula"-> PlayerImage=new Image(new FileInputStream(getImageFileNameUrsula()));                case "Flounder" -> PlayerImage=new Image(new FileInputStream(getImageFileNameFlounder()));                case "Sebastian"-> PlayerImage=new Image(new FileInputStream(getImageFileNameSebastian()));            }        } catch (FileNotFoundException e) {            e.printStackTrace();        }    }    public void setPearlsNumberView(Text pearlsNumber) {        this.pearlsNumber = pearlsNumber;    }}