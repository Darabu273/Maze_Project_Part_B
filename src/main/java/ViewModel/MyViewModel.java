package ViewModel;import Model.IModel;import Model.MyModel;import algorithms.mazeGenerators.Maze;import algorithms.search.Solution;import javafx.scene.input.KeyCode;import javafx.scene.input.KeyEvent;import java.util.Observable;import java.util.Observer;/** * MyViewModel (single tone class) -> transfer action and messages from model -> view and view -> model */public class MyViewModel extends Observable implements Observer {    private static MyViewModel ViewModelInstance; //singleton    private IModel model; //holds model instance    private MyViewModel() {        model = MyModel.getInstance();        model.assignObserver(this); //viewModel is observer of model    }    public static MyViewModel getInstance() {        if (ViewModelInstance == null){            ViewModelInstance = new MyViewModel();        }        return ViewModelInstance;    }    //getters    public int getPlayerRow() {        return model.getPlayerRow();    }    public int getPlayerCol() {        return model.getPlayerCol();    }    public Maze getMaze() {        return model.getMaze();    }    @Override    public void update(Observable o, Object arg) {        String action = arg.toString();        //In all cases we'll pass the same message we received from the Model to the View.        setChanged(); // let know the view we done        notifyObservers(action);    }    //ask model to generate maze    public void generateMaze(int row, int col) {        model.generateMaze(row, col);    }    //move player by user choice (keys)    public void movePlayer(KeyEvent keyEvent){        int direction = -1;        switch (keyEvent.getCode()){            //up, down, left, right            case NUMPAD8, UP -> direction = 8;            case NUMPAD2, DOWN -> direction = 2;            case NUMPAD4, LEFT -> direction = 4;            case NUMPAD6, RIGHT -> direction = 6;            //diagonals            case NUMPAD7 -> direction = 7;            case NUMPAD9 -> direction = 9;            case NUMPAD1 -> direction = 1;            case NUMPAD3 -> direction = 3;        }        if (direction > 0) //if it's a valid move            model.UpdatePlayerPosition(direction);    }    //move player by user choice (mouse drag)    public void movePlayerByMouseDragged(int counter, KeyCode keyCode){        //when the mouse dragged on the mazeDisplay we would like to see the player follow him in the same direction.        int direction = -1;        for (int i = 0; i < counter; i++) {            switch (keyCode) {                //up, down, left, right                case NUMPAD8, UP -> direction = 8;                case NUMPAD2, DOWN -> direction = 2;                case NUMPAD4, LEFT -> direction = 4;                case NUMPAD6, RIGHT -> direction = 6;            }            if (direction > 0)                model.UpdatePlayerPosition(direction);        }    }    //ask model to restart player position (to start position)    public void restartPlayer(){        model.UpdatePlayerPosition(0);    }    //ask model to solve the maze    public void solveMaze(){        model.solveMaze();    }    //ask model to return the solution    public Solution getSolution (){        return model.getSolution();    }    //ask model to shut down the servers    public void exitGame(){model.shutDownServers();}    //ask model to init the servers    public void initGameServers(){model.initServers();}    //ask model to set a loaded maze    public void setLoadedMaze(Maze loadedMaze) {        model.setLoadedMaze(loadedMaze);    }}